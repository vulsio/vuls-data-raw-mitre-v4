{
	"name": "CVE-2023-52589",
	"seq": "2023-52589",
	"type": "CAN",
	"status": "Candidate",
	"phase": {
		"text": "Assigned",
		"date": "20240302"
	},
	"desc": "In the Linux kernel, the following vulnerability has been resolved: media: rkisp1: Fix IRQ disable race issue In rkisp1_isp_stop() and rkisp1_csi_disable() the driver masks the interrupts and then apparently assumes that the interrupt handler won't be running, and proceeds in the stop procedure. This is not the case, as the interrupt handler can already be running, which would lead to the ISP being disabled while the interrupt handler handling a captured frame. This brings up two issues: 1) the ISP could be powered off while the interrupt handler is still running and accessing registers, leading to board lockup, and 2) the interrupt handler code and the code that disables the streaming might do things that conflict. It is not clear to me if 2) causes a real issue, but 1) can be seen with a suitable delay (or printk in my case) in the interrupt handler, leading to board lockup.",
	"refs": [
		{
			"text": "https://git.kernel.org/stable/c/7bb1a2822aa2c2de4e09bf7c56dd93bd532f1fa7",
			"source": "MISC",
			"url": "https://git.kernel.org/stable/c/7bb1a2822aa2c2de4e09bf7c56dd93bd532f1fa7"
		},
		{
			"text": "https://git.kernel.org/stable/c/870565f063a58576e8a4529f122cac4325c6b395",
			"source": "MISC",
			"url": "https://git.kernel.org/stable/c/870565f063a58576e8a4529f122cac4325c6b395"
		},
		{
			"text": "https://git.kernel.org/stable/c/bf808f58681cab64c81cd814551814fd34e540fe",
			"source": "MISC",
			"url": "https://git.kernel.org/stable/c/bf808f58681cab64c81cd814551814fd34e540fe"
		},
		{
			"text": "https://git.kernel.org/stable/c/fab483438342984f2a315fe13c882a80f0f7e545",
			"source": "MISC",
			"url": "https://git.kernel.org/stable/c/fab483438342984f2a315fe13c882a80f0f7e545"
		}
	],
	"votes": {}
}
